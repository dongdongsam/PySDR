.. _sampling-chapter:

##################
IQ Sampling
##################

이 장에서는 IQ 샘플링(IQ sampling)이라는 개념을 소개합니다. 이는 복소 샘플링(complex sampling) 또는 직교 샘플링(quadrature sampling)이라고도 불립니다. 또한 나이퀴스트 샘플링(Nyquist sampling), 복소수, RF 반송파(carrier), 하향변환(downconversion), 전력 스펙트럼 밀도(PSD)도 다룰 예정입니다.

IQ 샘플링은 SDR(Softw


*************************
Sampling Basics
*************************

IQ 샘플링을 다루기 전에, 먼저 샘플링(sampling)이 무엇인지부터 짚고 넘어가겠습니다. 아마도 마이크로 오디오를 녹음하면서 모르게 샘플링을 경험해본 적이 있을 것입니다. 마이크는 음파(sound wave)를 전기 신호(전압 레벨)로 변환하는 트랜스듀서(transducer)입니다. 이 전기 신호는 아날로그-디지털 변환기(ADC, Analog-to-Digital Converter)를 통해 디지털 형태의 파형으로 바뀝니다. 정리하자면, 마이크가 음파를 받아 전기로 바꾸고, 그 전기가 다시 숫자로 변환되는 과정입니다. ADC는 아날로그 세계와 디지털 세계를 잇는 다리 역할을 하는 셈이죠. SDR도 놀라울 정도로 비슷하게 동작합니다. 다만 마이크 대신 안테나를 사용한다는 점이 다릅니다(물론 ADC도 함께 사용합니다). 두 경우 모두 ADC가 전압 레벨을 샘플링합니다. SDR의 경우 “라디오 전파가 들어와서 숫자가 나간다”라고 생각하면 됩니다.

오디오이든 무선 주파수이든, 신호를 디지털로 캡처·처리·저장하려면 반드시 샘플링이 필요합니다. 언뜻 단순해 보일 수 있지만, 샘플링에는 생각보다 많은 개념이 숨어 있습니다. 좀 더 기술적인 관점에서 보면, 샘플링이란 특정 시점의 값을 잡아내어 디지털로 저장하는 과정입니다. 예를 들어 임의의 함수 :math:`S(t)` 가 있다고 합시다. 이 함수는 무엇이든 표현할 수 있으며, 연속적인 함수이므로 우리가 샘플링하고자 하는 대상이 됩니다.


.. image:: ../_images/sampling.svg
   :align: center
   :target: ../_images/sampling.svg
   :alt: 신호 샘플링의 개념을 나타낸 그림으로, 샘플 주기 T가 표시되어 있으며, 파란 점들이 샘플을 의미합니다.

우리는 :math:`S(t)`의 값을 일정한 간격 :math:`T` 초마다 기록합니다. 이 :math:`T`를 **샘플 주기(sample period)**라고 합니다. 초당 샘플링하는 횟수, 즉 1초에 취하는 샘플 개수는 단순히 :math:`\frac{1}{T}`로 표현되며, 이를 **샘플링 주파수(sample rate)**라고 부릅니다. 샘플링 주파수는 샘플 주기의 역수입니다. 예를 들어, 샘플링 주파수가 10 Hz라면 샘플 주기는 0.1초가 되며, 샘플 간격은 0.1초가 됩니다. 실제 응용에서는 샘플링 주파수가 수백 kHz에서 수십 MHz, 또는 그 이상이 되는 경우가 많습니다. 신호를 샘플링할 때 샘플링 주파수는 매우 중요한 매개변수이므로 반드시 주의해야 합니다.

수학적으로 표현하면, :math:`S_n`을 샘플 :math:`n`이라 하며, 보통 정수 0부터 시작합니다. 이 표기법을 사용하면 샘플링 과정은 :math:`S_n = S(nT)` (단, :math:`n`은 정수)로 나타낼 수 있습니다. 즉, 연속 신호 :math:`S(t)`를 :math:`nT` 시점마다 평가하는 것입니다.


*************************
Nyquist Sampling
*************************

주어진 신호에 대해 가장 큰 질문은 “얼마나 빠르게 샘플링해야 하는가?”입니다. 먼저 주파수 f의 단순한 사인파 신호(초록색)를 생각해 보겠습니다. 샘플링 주파수를 Fs라고 하고(파란색 점으로 표시), 만약 Fs = f로 샘플링한다면 다음과 같은 결과를 얻게 됩니다:

.. image:: ../_images/sampling_Fs_0.3.svg
   :align: center

위 그림의 빨간 점선은 동일한 샘플들로부터 재구성될 수 있는 또 다른(잘못된) 함수를 보여줍니다. 즉, 샘플링 주파수가 너무 낮아 동일한 샘플들이 두 개의 서로 다른 함수에서 나올 수 있음을 의미합니다. 이런 모호성이 존재하면 원래 신호를 정확히 복원할 수 없습니다.

이번에는 Fs = 1.2f로 조금 더 빠르게 샘플링해 봅시다:

.. image:: ../_images/sampling_Fs_0.36.svg
   :align: center

여전히 다른 신호가 이 샘플들에 맞을 수 있습니다. 즉, 누군가 이 샘플 목록만 주면 원래 신호가 무엇이었는지 알 수 없다는 뜻입니다.

그럼 Fs = 1.5f일 때는 어떨까요?

.. image:: ../_images/sampling_Fs_0.45.svg
   :align: center
   :alt: 신호를 충분히 빠르게 샘플링하지 못했을 때(나이퀴스트 속도 이하) 발생하는 샘플링 모호성 예시

아직도 충분하지 않습니다! DSP 이론에 따르면, 모호성을 없애려면 신호 주파수의 **두 배**로 샘플링해야 합니다:

.. image:: ../_images/sampling_Fs_0.6.svg
   :align: center

이번에는 잘못된 신호가 존재하지 않습니다. 샘플링 속도가 충분히 빠르기 때문에, 이 샘플들에 맞는 신호는 지금 보이는 신호 하나뿐입니다(더 높은 주파수의 경우는 나중에 다루겠습니다).

위 예시는 단순한 사인파였지만, 실제 신호는 여러 주파수 성분을 가집니다. 따라서 어떤 신호를 정확히 샘플링하려면 “샘플링 주파수는 반드시 해당 신호의 최대 주파수 성분의 두 배 이상”이어야 합니다. 다음 그림은 주파수 영역 예시를 통해 이를 시각화한 것입니다. 항상 잡음 바닥(noise floor)이 존재하기 때문에 최고 주파수는 보통 근사치로 취급합니다:

.. image:: ../_images/max_freq.svg
   :align: center
   :target: ../_images/max_freq.svg
   :alt: 나이퀴스트 샘플링은 샘플링 속도가 신호의 최대 대역폭보다 커야 함을 의미

즉, 가장 높은 주파수 성분을 찾아 두 배로 곱한 값을 최소 샘플링 속도로 정해야 합니다. 이 최소 샘플링 속도를 나이퀴스트 속도(Nyquist Rate)라고 합니다. 다시 말해, 나이퀴스트 속도는 유한 대역폭 신호가 모든 정보를 잃지 않고 샘플링될 수 있는 최소한의 속도입니다. 이는 DSP와 SDR에서 연속 신호와 이산 신호를 이어주는 매우 중요한 이론입니다.

.. image:: ../_images/nyquist_rate.png
   :scale: 70%
   :align: center

만약 충분히 빠르게 샘플링하지 못하면 앨리어싱(aliasing)이라는 현상이 발생합니다. 이는 반드시 피해야 하며, 이후에 자세히 다룹니다. 일반적으로 SDR(및 대부분의 수신기)은 샘플링 직전에 Fs/2 이상의 성분을 제거하는 필터를 사용합니다. 만약 샘플링 주파수가 너무 낮으면, 이 필터가 신호 일부를 잘라내 버리게 됩니다. SDR은 앨리어싱과 기타 왜곡이 없는 샘플을 제공하기 위해 많은 노력을 기울입니다. SDR의 안티앨리어싱 필터는 통과대역(passband)에서 저지대역(stopband)으로 즉시 전환되지 않고 작은 전이대역(transition band)이 필요하기 때문에, 경험적으로는 전체 샘플링 주파수 중 4/5만 실제로 사용 가능한 대역폭이라고 가정합니다. 이를 “Sean의 4/5 법칙”이라고 부릅니다.


*************************
Quadrature Sampling
*************************

"Quadrature"라는 용어는 여러 의미가 있지만, DSP와 SDR 맥락에서는 위상이 90도 차이나는 두 파형을 의미합니다. 왜 하필 90도일까요? 위상이 180도 차이나면 사실상 같은 파형에 -1을 곱한 것과 같기 때문에 큰 차이가 없습니다. 반면 90도 차이나면 두 파형은 직교(orthogonal)하게 되고, 직교(Orthogonal) 함수로 할 수 있는 멋진 일들이 많습니다. 단순화를 위해 위상이 90도 차이나는 두 사인파를 사인(sin)과 코사인(cos)으로 사용합니다.

이제 사인과 코사인의 **진폭**을 나타내는 변수를 정의해 보겠습니다. 코사인에는 :math:`I`, 사인에는 :math:`Q`를 사용합니다:

.. math::
  I \cos(2\pi ft)

  Q \sin(2\pi ft)

I와 Q가 각각 1일 때를 시각적으로 그리면 다음과 같습니다:

.. image:: ../_images/IQ_wave.png
   :scale: 70%
   :align: center
   :alt: I와 Q를 사인파의 진폭으로 시각화한 그림, 두 신호가 합쳐짐

코사인 항은 "동상(in phase)" 성분이므로 I라 부르고, 사인 항은 위상이 90도 차이나므로 "직교(quadrature)" 성분, 즉 Q라 부릅니다. 사실 Q를 cos에, I를 sin에 할당하더라도 대부분의 경우 큰 차이는 없습니다.

IQ 샘플링은 송신기의 관점에서 보면 이해하기가 더 쉽습니다. 주파수 :math:`f` (Hz)에서 RF 신호를 공중으로 송신한다고 가정해 봅시다. 우리는 이 주파수의 사인파를 만들어 그 진폭 :math:`A`와 위상 :math:`\phi`를 제어하고 싶습니다:

.. math::

 A \cos(2 \pi f t - \phi)

여기서 마이너스 부호는 단순히 관습일 뿐 개념 이해에는 중요하지 않습니다. 특정 순간마다 송신하고 싶은 진폭과 위상이 달라질 수 있으므로, 이를 시간의 함수로 표현하면 더 정확합니다:

.. math::

 A(t) \cos(2 \pi f t - \phi(t))

RF 회로에서는 사인파의 진폭을 제어하는 것은 쉽지만 위상을 제어하는 것은 어렵습니다. 따라서 다음 삼각함수 항등식을 활용합니다: :math:`a \cos(x) + b \sin(x) = A \cos(x - \phi)`. 이 항등식은 동일한 주파수의 cos와 sin을 더하면 위상 :math:`\phi`와 진폭 :math:`A`를 갖는 하나의 cos로 표현할 수 있음을 말해줍니다. 이제 a와 b 대신 I와 Q를 쓰고, 다시 :math:`2 \pi f t`를 넣으면 다음과 같습니다:

.. math::

 A \cos(2 \pi f t - \phi)
 = I \cos(2 \pi f t) + Q \sin(2 \pi f t)

여기서

.. math::

 A = \sqrt{I^2 + Q^2}

 \phi = \tan^{-1}\left(\frac{Q}{I}\right)

이 I와 Q 방식을 활용하면, 원하는 진폭과 위상을 손쉽게 송신할 수 있으며, 그 회로 구조는 대략 다음과 같습니다:

.. image:: ../_images/IQ_diagram.png
   :scale: 80%
   :align: center
   :alt: I와 Q가 반송파에 변조되는 방식을 보여주는 다이어그램

IQ 샘플은 단일 복소수 :math:`I + jQ`로 표현할 수 있습니다. 우리는 이 IQ 샘플을 사인파에 **변조(modulate)**할 수 있고, 그 진폭과 위상은 IQ 샘플에 의해 결정됩니다:

.. math::

 x(t) = I \cos(2\pi ft) + Q \sin(2\pi ft)

 \qquad \qquad \qquad \qquad = \left(\sqrt{I^2+Q^2}\right) \cos\left(2\pi ft - \tan^{-1}\left(\frac{Q}{I}\right)\right)

수식은 그렇지만, 실제로 위상이 90도 차이나는 두 사인파를 더하는 것을 직접 실험해 보면 더 직관적입니다. 아래 영상에는 I(코사인 진폭)과 Q(사인 진폭)를 조절하는 슬라이더가 있습니다. 표시되는 것은 코사인(빨간색), 사인(파란색), 그리고 두 신호의 합(녹색)입니다:

.. image:: ../_images/IQ3.gif
   :scale: 100%
   :align: center
   :target: ../_images/IQ3.gif
   :alt: GNU Radio 애니메이션, I와 Q를 사인파 진폭으로 보여주고 합쳐지는 모습

이 pyqtgraph 기반 Python 앱의 코드는 `여기 <https://raw.githubusercontent.com/777arc/PySDR/master/figure-generating-scripts/sin_plus_cos.py>`_ 에서 볼 수 있습니다.

핵심은 cos()와 sin()을 더하면 같은 주파수의 순수한 사인파가 되는데, 위상과 진폭은 달라진다는 점입니다. 두 성분 중 하나를 줄이거나 늘리면 위상이 이동하고 진폭도 변합니다. 이는 모두 :math:`a \cos(x) + b \sin(x) = A \cos(x-\phi)`라는 항등식의 결과입니다. 이 현상의 "유용성"은 원하는 위상과 진폭을 단순히 I와 Q의 진폭을 조절하여 얻을 수 있다는 데 있습니다(코사인이나 사인의 위상을 직접 바꿀 필요가 없습니다). 예를 들어, 진폭을 일정하게 유지하면서 위상을 원하는 대로 만들 수도 있습니다. 송신기 입장에서는 이는 매우 강력한 능력입니다. 전자기파로 공중에 퍼지려면 반드시 정현파 신호를 송신해야 하므로, 위상과 진폭을 조절하는 것이 핵심인데, I와 Q의 진폭을 조절하고 더하는 것이 훨씬 간단합니다. 또한 이를 통해 반송파와 무관하게 베이스밴드 신호를 더 편리하게 표현할 수 있습니다.


*************************
Complex Numbers
*************************

결국 IQ 샘플링은 진폭과 위상을 나타내는 또 다른 방법이며, 이는 복소수와 복소 평면 위 표현으로 이어집니다. 복소수를 다른 수업에서 접한 적이 있을 수도 있습니다. 예를 들어, 복소수 0.7-0.4j를 생각해 봅시다:

.. image:: ../_images/complex_plane_1.png
   :scale: 70%
   :align: center

복소수는 실제 부분(real part)과 허수 부분(imag part) 두 개의 수로 이루어진 것입니다. 복소수에는 진폭과 위상도 있으며, 이를 점(point)보다는 벡터(vector)로 생각하는 것이 이해하기 쉽습니다. 진폭은 원점에서 점까지의 거리(즉 벡터의 길이)이고, 위상은 벡터가 0도와 이루는 각도입니다. 여기서 0도는 양의 실수축으로 정의합니다:

.. image:: ../_images/complex_plane_2.png
   :scale: 70%
   :align: center
   :alt: 복소 평면 위의 벡터

이러한 사인파의 표현을 “페이저 다이어그램(phasor diagram)”이라고 부릅니다. 단순히 복소수를 벡터처럼 그려주는 것입니다. 이제 예제 복소수 0.7-0.4j의 진폭과 위상을 계산해 보겠습니다. 일반적으로 복소수의 실수부를 :math:`a`, 허수부를 :math:`b`라고 하면:

.. math::
  \mathrm{magnitude} = \sqrt{a^2 + b^2} = 0.806

  \mathrm{phase} = \tan^{-1} \left( \frac{b}{a} \right) = -29.7^{\circ} = -0.519 \quad \mathrm{radians}

Python에서는 np.abs(x), np.angle(x) 함수를 사용해 진폭과 위상을 구할 수 있습니다. 입력은 단일 복소수일 수도 있고, 복소수 배열일 수도 있으며, 출력은 **실수**(float 자료형)입니다.

여기까지 읽으면 이 벡터/페이저 다이어그램이 IQ 표현과 어떻게 연결되는지 감이 올 것입니다. I는 실수부, Q는 허수부입니다. 이제부터는 복소 평면을 그릴 때 실수부와 허수부 대신 I와 Q로 표시하겠습니다. 여전히 복소수이긴 합니다!

.. image:: ../_images/complex_plane_3.png
   :scale: 70%
   :align: center

이제 예제 점 0.7-0.4j를 송신한다고 가정해 보겠습니다. 송신 신호는 다음과 같습니다:

.. math::

 x(t) = I \cos(2\pi ft)  + Q \sin(2\pi ft)

 \quad \quad \quad = 0.7 \cos(2\pi ft) - 0.4 \sin(2\pi ft)

여기서 삼각함수 항등식 :math:`a \cos(x) + b \sin(x) = A \cos(x-\phi)`를 적용합니다. :math:`A`는 :math:`\sqrt{I^2 + Q^2}`로 구한 진폭이고, :math:`\phi`는 :math:`\tan^{-1}(Q/I)`로 구한 위상입니다. 위 식은 다음과 같이 바뀝니다:

.. math::
  x(t) = 0.806 \cos(2\pi ft + 0.519)

즉, 처음에는 복소수로 시작했지만 실제로 송신되는 것은 특정한 진폭과 위상을 가진 **실수 신호**입니다. 전자기파로 허수 성분을 송신할 수는 없습니다. 다만 우리가 송신하는 신호를 복소수/허수부로 표현해 두는 것입니다. 주파수 :math:`f`에 대해서는 곧 다루겠습니다.


*************************
Complex Numbers in FFTs
*************************

위에서 다룬 복소수들은 시간 영역 샘플로 가정했지만, FFT를 수행할 때도 복소수를 만나게 됩니다. 이전 장에서 푸리에 급수와 FFT를 다룰 때는 복소수에 대해 깊게 들어가지 않았습니다.

일련의 샘플에 대해 FFT를 수행하면, 그 샘플들의 주파수 영역 표현을 얻을 수 있습니다. FFT는 해당 샘플 집합에 어떤 주파수들이 존재하는지 찾아내며, FFT의 크기(magnitude)는 각 주파수의 세기를 나타냅니다. 하지만 FFT가 하는 일은 이것뿐만이 아닙니다. 각 주파수 성분이 시간 영역 신호를 재구성할 수 있도록 필요한 지연(시간 이동, delay)까지 계산합니다. 이 지연이 바로 FFT의 위상(phase)입니다.

따라서 FFT의 출력은 복소수 배열입니다. 각 복소수는 크기와 위상을 제공하며, 배열에서의 인덱스는 주파수를 의미합니다. 만약 그 주파수·크기·위상에 맞는 사인파들을 생성해 모두 합친다면, 원래의 시간 영역 신호(또는 매우 근사한 형태)를 얻게 됩니다. 그리고 이 근사 정도를 보장해주는 것이 바로 나이퀴스트 샘플링 정리입니다.


*************************
Receiver Side
*************************

이번에는 신호(예: FM 라디오 신호)를 수신하려는 라디오 수신기의 관점에서 IQ 샘플링을 살펴보겠습니다. 다이어그램은 다음과 같이 표현됩니다:

.. image:: ../_images/IQ_diagram_rx.png
   :scale: 70%
   :align: center
   :alt: 입력 신호를 사인파와 90도 위상 이동된 사인파로 곱해 IQ 샘플을 수신하는 방식

안테나로 들어오는 것은 실수(real) 신호이며, 이것이 IQ 값으로 변환됩니다. I와 Q 가지(branch)를 각각 따로 샘플링하기 위해 두 개의 ADC를 사용하고, 이렇게 얻은 I와 Q 값을 쌍으로 묶어 복소수로 저장합니다. 다시 말해, 각 시점마다 I 값 하나와 Q 값 하나를 샘플링하여 :math:`I + jQ` 형태로 결합하는 것입니다(즉, IQ 샘플 하나당 복소수 하나). 이 과정에는 항상 샘플링 속도(sample rate)가 존재합니다. 예를 들어 누군가 “내 SDR은 2 MHz 샘플링 속도로 동작한다”고 말한다면, 이는 초당 200만 개의 IQ 샘플을 수신한다는 뜻입니다.

IQ 샘플들이 주어지면, 그것은 복소수들의 1차원 배열(벡터)처럼 보일 것입니다. 이 개념이 바로 지금까지 이 장에서 쌓아온 핵심이며, 이제 드디어 도달했습니다.

이 교재 전반에서 IQ 샘플이 어떻게 동작하는지, SDR로 수신하고 송신하는 방법, Python으로 처리하는 방법, 파일로 저장하여 나중에 분석하는 방법에 대해 **아주** 친숙해지게 될 것입니다.

마지막으로 중요한 점은: 위 그림은 SDR **내부에서** 일어나는 일을 설명한 것이라는 점입니다. 우리가 직접 사인파를 만들거나, 90도 위상 이동을 시키거나, 곱하거나, 합할 필요는 없습니다. SDR이 대신 수행해 줍니다. 우리는 SDR에 어떤 주파수를 샘플링할지, 또는 어떤 주파수로 샘플을 송신할지만 지정하면 됩니다. 수신기 측에서는 SDR이 IQ 샘플을 제공하고, 송신기 측에서는 우리가 IQ 샘플을 SDR에 제공해야 합니다. 데이터 타입 측면에서 IQ 샘플은 보통 복소수 정수(complex int)나 복소수 부동소수점(complex float) 형태입니다.


.. _downconversion-section:

**************************
Carrier and Downconversion
**************************

지금까지는 주파수에 대해 깊게 다루지 않았지만, cos()와 sin()이 포함된 식에는 :math:`f`가 있었습니다. 이 :math:`f`는 우리가 공중으로 실제 송신하는 신호의 중심 주파수, 즉 전자기파의 주파수를 의미합니다. 이를 "반송파(carrier)"라고 부르며, 특정 RF 주파수에서 신호를 운반하기 때문에 붙은 이름입니다. SDR로 특정 주파수에 맞춰 튜닝해 샘플을 수신하면, 실제 정보는 I와 Q에 저장되고 반송파 자체는 I와 Q에 나타나지 않습니다.

FM 라디오, WiFi, Bluetooth, LTE, GPS 등 무선 신호들은 보통 100 MHz에서 6 GHz 사이의 주파수(즉, 반송파)를 사용합니다. 이 범위는 전파가 공기 중에서 잘 전파되면서도, 지나치게 긴 안테나나 과도한 전력이 필요하지 않기 때문에 유용합니다. 예를 들어 전자레인지는 2.4 GHz 전자기파로 음식을 가열합니다. 만약 도어에 누설이 생기면 WiFi 신호에 간섭을 주거나 피부에 화상을 입힐 수도 있습니다. 전자기파의 또 다른 형태는 빛이며, 가시광선의 주파수는 약 500 THz입니다. 너무 높기 때문에 일반적인 안테나로는 송신할 수 없고, LED 같은 반도체 소자를 사용합니다. LED는 전자가 반도체의 원자 궤도 사이를 뛰어넘을 때 빛을 방출하며, 이동하는 거리(에너지)에 따라 색이 달라집니다. 기술적으로 RF는 약 20 kHz에서 300 GHz 범위를 의미하며, 이 주파수 대역에서 진동하는 전류의 에너지가 도체(안테나)를 통해 공간으로 방사될 수 있습니다. 현대적으로 유용한 범위는 주로 100 MHz ~ 6 GHz이고, 6 GHz 이상의 대역은 수십 년 동안 레이더나 위성 통신에 사용되어 왔으며, 최근에는 5G "mmWave"(24–29 GHz) 대역으로도 쓰입니다.

IQ 값을 빠르게 변화시키며 반송파를 송신하는 과정을 “반송파를 **변조(modulate)**한다”고 합니다. I와 Q를 바꾸면 반송파의 위상과 진폭이 변합니다. 또 다른 방법은 반송파 주파수를 조금 위아래로 바꾸는 것인데, 이것이 FM 라디오 방식입니다. 여기서 혼동하기 쉬운 점은, 송신하려는 신호 자체(여러 주파수 성분을 포함)와 그것을 실어 보내는 반송파 주파수는 다르다는 것입니다. 이 구분은 베이스밴드(baseband)와 밴드패스(bandpass) 신호를 배울 때 명확해질 것입니다.

샘플링으로 다시 돌아가 보겠습니다. 만약 안테나에서 들어온 신호를 바로 하나의 ADC로만 샘플링한다고 가정해봅시다. WiFi나 Bluetooth처럼 반송파 주파수가 2.4 GHz라면, 최소 4.8 GHz로 샘플링해야 합니다. 이는 너무 빠르며, 그렇게 동작하는 ADC는 수천 달러에 달합니다. 그래서 사용하는 방법이 **하향 변환(downconversion)**입니다. 우리가 샘플링하려는 신호를 DC(0 Hz) 주변으로 옮겨놓는 것입니다. 샘플링 이전 단계에서 반송파를 제거해 버리는 것이죠. 다음과 같은 식에서:

.. math::

 I \underbrace{\cos(2\pi ft)}_{carrier} \ + \ \ Q \underbrace{\sin(2\pi ft)}_{carrier}

단순히 I와 Q만 남도록 변환합니다.

주파수 영역에서 하향 변환을 시각화하면 다음과 같습니다:

.. image:: ../_images/downconversion.png
   :scale: 60%
   :align: center
   :alt: RF 신호를 0 Hz 또는 베이스밴드로 주파수 이동시키는 하향 변환 과정

하향 변환 후에는 중심이 0 Hz로 이동하므로, 최대 주파수는 더 이상 2.4 GHz가 아니라 신호 대역폭에 의해 결정됩니다. 대부분의 신호는 대역폭이 100 kHz에서 40 MHz 정도이므로, 훨씬 낮은 속도로 샘플링할 수 있습니다. 예를 들어 B2X0 USRP나 PlutoSDR 같은 장비에 들어 있는 RF 집적회로(RFIC)는 최대 56 MHz까지 샘플링할 수 있으며, 이는 우리가 다루는 대부분의 신호에 충분합니다.

다시 강조하지만, 하향 변환(Down Converting)은 SDR 내부에서 수행됩니다. 사용자는 원하는 주파수를 설정해주기만 하면 됩니다. 하향 변환(및 상향 변환)은 믹서(mixer)라는 부품이 수행하며, 다이어그램에서는 보통 원 안의 곱셈 기호로 표현됩니다. 믹서는 입력 신호를 받아 주파수 변환된 신호를 출력하며, 세 번째 포트로는 오실레이터가 공급됩니다. 이 오실레이터의 주파수가 곧 신호에 적용될 주파수 이동량을 결정합니다. 본질적으로 믹서는 곱셈 함수이며, 사인파와 곱하면 주파수 이동이 일어난다는 사실을 떠올리면 됩니다.

마지막으로 신호가 공기를 통해 얼마나 빨리 이동하는지도 궁금할 수 있습니다. 고등학교 물리에서 배웠듯이, 전파는 단순히 저주파의 전자기파(약 3 kHz ~ 80 GHz)입니다. 가시광선 역시 전자기파지만 훨씬 높은 주파수(400 THz ~ 700 THz)입니다. 모든 전자기파는 진공이나 공기에서 빛의 속도, 약 3×10^8 m/s로 이동합니다. 속도가 일정하기 때문에, 한 주기의 파동이 이동하는 거리(즉, 파장)는 주파수에 의해 결정됩니다. 이를 파장(:math:`\lambda`)이라 하며, 관계식은 다음과 같습니다:

.. math::
 f = \frac{c}{\lambda}

여기서 :math:`c`는 빛의 속도로, 보통 3e8로 두고, :math:`f`는 Hz, :math:`\lambda`는 미터 단위입니다. 무선 통신에서는 안테나를 설계할 때 이 관계가 중요해집니다. 특정 반송파 주파수 :math:`f`에서 신호를 수신하려면 해당 파장 :math:`\lambda`에 맞는 안테나가 필요하며, 보통 안테나 길이는 :math:`\lambda/2` 또는 :math:`\lambda/4`입니다. 다만 주파수나 파장과 관계없이, 신호에 담긴 정보는 송신기에서 수신기로 항상 빛의 속도로 전달됩니다. 공기를 통한 지연을 계산할 때의 경험 법칙은 “빛은 1 나노초에 약 1 피트(30 cm)를 이동한다”는 것입니다. 또 다른 법칙: 정지 궤도 위성까지 왕복하는 신호는 약 0.25초가 걸립니다.


**************************
Receiver Architectures
**************************

"수신기(Receiver Side)" 섹션에 나온 그림은 입력 신호가 하향 변환되어 I와 Q로 분리되는 과정을 보여줍니다. 이러한 구조를 **직접 변환(direct conversion)** 또는 **제로 IF(zero IF)**라고 부르는데, RF 신호가 직접 베이스밴드로 변환되기 때문입니다.

또 다른 방법은 아예 하향 변환을 하지 않고, 0 Hz부터 샘플링 속도의 절반까지 모든 것을 포착할 만큼 매우 빠르게 샘플링하는 것입니다. 이를 **직접 샘플링(direct sampling)** 또는 **직접 RF(direct RF)**라고 하며, 매우 비싼 ADC 칩이 필요합니다.

세 번째 아키텍처는 오래된 라디오에서 널리 쓰였던 방식으로, 오늘날에도 인기 있는 구조인데, 이를 **수퍼헤테로다인(superheterodyne)**이라고 부릅니다. 이 방식은 하향 변환을 하긴 하지만 0 Hz까지는 내리지 않고, 관심 있는 신호를 중간 주파수(IF, Intermediate Frequency)로 이동시킵니다.

또한 저잡음 증폭기(LNA, Low-Noise Amplifier)는 입력단에서 매우 작은 전력을 가진 신호를 증폭하도록 설계된 앰프입니다.

아래 그림은 이 세 가지 대표적인 수신기 아키텍처를 블록 다이어그램으로 보여줍니다. 실제로는 이들의 변형 및 하이브리드 구조도 존재합니다:

.. image:: ../_images/receiver_arch_diagram.svg
   :align: center
   :target: ../_images/receiver_arch_diagram.svg
   :alt: 세 가지 대표적인 수신기 아키텍처: 직접 샘플링, 직접 변환, 수퍼헤테로다인


***********************************
Baseband and Bandpass Signals
***********************************

우리는 0 Hz를 중심으로 한 신호를 **베이스밴드(baseband)**에 있다고 합니다. 반대로, **밴드패스(bandpass)**는 신호가 0 Hz 근처가 아닌 어떤 RF 주파수에 존재하며, 무선 전송을 위해 상향 변환된 상태를 의미합니다. "베이스밴드 전송"이라는 개념은 존재하지 않습니다. 허수 신호는 직접 전송할 수 없기 때문입니다.

베이스밴드 신호는 Section :ref:`downconversion-section`의 오른쪽 그림처럼 정확히 0 Hz에 위치할 수도 있고, 아래 그림의 두 신호처럼 0 Hz 근처에 위치할 수도 있습니다. 이런 경우도 여전히 베이스밴드 신호로 간주합니다. 그림에는 또한 매우 높은 주파수 :math:`f_c`를 중심으로 한 밴드패스 신호 예시도 표시되어 있습니다:

.. image:: ../_images/baseband_bandpass.png
   :scale: 50%
   :align: center
   :alt: 베이스밴드와 밴드패스 비교

또한 "중간 주파수(intermediate frequency, IF)"라는 용어도 종종 듣게 되는데, 이는 라디오에서 베이스밴드와 밴드패스/RF 사이의 중간 변환 단계에서 사용됩니다.

우리가 신호를 생성, 기록, 분석할 때 보통 베이스밴드에서 다루는 이유는 더 낮은 샘플링 속도를 사용할 수 있기 때문입니다(앞 절에서 설명했습니다). 중요한 점은, 베이스밴드 RF 신호는 **복소 신호(complex signals)**인 반면, 실제 RF에서 송신되는 밴드패스 신호는 **실수 신호(real signals)**라는 것입니다. 안테나를 통해 송신되는 신호는 반드시 실수여야 하며, 복소/허수 신호를 직접 송신할 수는 없습니다. 신호가 복소 신호인지 확실히 알 수 있는 방법은 음수 주파수와 양수 주파수 성분이 정확히 동일하지 않은 경우입니다. 복소수 표현 덕분에 음수 주파수를 다룰 수 있는데, 실제로는 음수 주파수가 존재하는 것이 아니라 반송파 주파수 아래쪽 성분을 표현하는 방식입니다.

만약 신호에 허수 성분이 없다면 Q 값이 전혀 없는 것이며(혹은 모든 Q 값이 0인 경우와 같습니다), 이는 위상 이동이 없는 순수한 코사인 신호만 있는 것과 같습니다. 위상 이동이 없는 코사인 신호들의 합은 양·음 주파수 성분이 대칭적이므로 주파수 영역에서 y축 대칭 구조를 보입니다.

앞에서 살펴본 복소수 0.7 - 0.4j 예시는 사실상 베이스밴드 신호의 샘플 하나라고 볼 수 있습니다. 대부분의 경우 IQ 샘플(복소 샘플)을 본다면, 그것은 베이스밴드 신호입니다. RF 신호를 직접 디지털로 표현하거나 저장하는 경우는 거의 없는데, 데이터 양이 방대할 뿐 아니라 실제로는 RF 스펙트럼의 일부분만 관심 대상이기 때문입니다.

***************************
DC Spike and Offset Tuning
***************************

SDR를 사용하다 보면 FFT 중앙에 큰 스파이크가 나타나는 경우가 많습니다. 이를 **DC 오프셋(DC offset)**, **DC 스파이크(DC spike)**, 또는 **LO 누설(LO leakage)**이라고 부릅니다. 여기서 LO는 로컬 오실레이터(local oscillator)를 의미합니다.

다음은 DC 스파이크의 예시입니다:

.. image:: ../_images/dc_spike.png
   :scale: 50%
   :align: center
   :alt: 전력 스펙트럼 밀도(PSD)에서 나타난 DC 스파이크

SDR은 특정 중심 주파수에 맞추어 동작하므로, FFT의 0 Hz 부분이 곧 중심 주파수에 해당합니다. 하지만 DC 스파이크가 있다고 해서 반드시 중심 주파수에서 실제 에너지가 존재한다는 뜻은 아닙니다. 만약 FFT에서 DC 스파이크만 보이고 나머지가 잡음처럼 보인다면, 실제로는 해당 주파수에 신호가 없을 가능성이 큽니다. (즉, 유령 신호일 수 있다는 소리)

DC 오프셋은 **직접 변환 수신기(direct conversion receiver)**에서 흔히 나타나는 현상인데, PlutoSDR, RTL-SDR, LimeSDR, 그리고 Ettus USRP 계열 SDR들이 사용하는 아키텍처입니다. 직접 변환 수신기에서는 로컬 오실레이터(LO)가 실제 주파수의 신호를 베이스밴드로 하향 변환합니다. 이 과정에서 LO의 누설이 관측 대역폭의 중앙(0 Hz 부근)에 나타납니다. LO 누설은 주파수 결합으로 인해 생긴 추가적인 에너지인데, 원하는 출력 신호 근처에 발생하므로 제거하기 어렵습니다. 많은 RF 집적회로(RFIC)에는 자동 DC 오프셋 제거 기능이 내장되어 있지만, 보통 신호가 존재할 때만 작동합니다. 그렇기 때문에 신호가 없을 때 DC 스파이크가 두드러지게 나타납니다.

DC 오프셋을 처리하는 빠른 방법 중 하나는 신호를 **오버샘플링(oversampling)**하고 중심 주파수를 약간 비켜서 설정하는 것입니다. 이를 *오프셋 튜닝(offset tuning)*이라고 부릅니다. 예를 들어, 우리가 100 MHz에서 5 MHz 대역폭을 보고 싶다고 가정합시다. 대신 95 MHz를 중심 주파수로 두고, 20 MHz 샘플링 속도로 신호를 수집할 수 있습니다.

.. image:: ../_images/offtuning.png
   :scale: 40 %
   :align: center
   :alt: DC 스파이크를 피하기 위한 오프셋 튜닝 과정

위 그림에서 파란 상자는 SDR이 실제로 샘플링한 대역을, 초록 상자는 우리가 원하는 대역을 나타냅니다. LO는 95 MHz에 맞춰지는데, 이는 SDR이 우리가 요청한 주파수이기 때문입니다. 이 경우 LO는 초록 상자 밖에 있으므로 DC 스파이크가 발생하지 않습니다.

단점은, 우리가 원하는 신호가 100 MHz에 중심을 두고 5 MHz 대역폭만 포함해야 한다면, 직접 주파수 이동(frequency shift), 필터링, 다운샘플링을 수행해야 한다는 점입니다(이는 뒤에서 배우게 됩니다). 다행히도 많은 SDR에는 이 오프튜닝(LO 오프셋 적용) 기능이 내장되어 있어서, 자동으로 오프튜닝을 수행한 뒤 원하는 중심 주파수로 주파수를 이동시켜 줍니다. SDR이 내부적으로 이 과정을 처리해 주면 USB나 이더넷 연결을 통해 더 높은 샘플링 속도를 전송하지 않아도 되므로, 연결 대역폭이 병목이 되는 문제를 줄일 수 있습니다.

이 DC 오프셋 부분은 이 교재가 일반 DSP 교재와 다른 점을 잘 보여줍니다. 보통의 DSP 교재는 샘플링 이론은 다루지만, DC 오프셋처럼 실제 구현에서 흔히 발생하는 문제들은 다루지 않는 경우가 많습니다.



****************************
Sampling Using our SDR
****************************

SDR에서 샘플링을 수행하는 구체적인 방법은 아래 장들을 참고하세요:

* :ref:`pluto-chapter` 챕터
* :ref:`usrp-chapter` 챕터


*************************
Calculating Average Power
*************************

RF DSP에서는 신호의 존재 여부를 감지하거나 DSP 처리를 시작하기 전에 신호의 **전력(power)**을 계산하는 경우가 많습니다. 이산 복소 신호(즉, 샘플링된 신호)의 평균 전력은 각 샘플의 크기(magnitude)를 구해 제곱한 뒤, 그 평균을 취하면 됩니다:

.. math::
   P = \frac{1}{N} \sum_{n=1}^{N} |x[n]|^2

여기서 복소수의 절댓값은 단순히 그 크기, 즉 :math:`\sqrt{I^2+Q^2}` 입니다.

Python으로 평균 전력을 계산하면 다음과 같습니다:

.. code-block:: python

   avg_pwr = np.mean(np.abs(x)**2)

샘플링된 신호의 평균 전력을 계산할 때 아주 유용한 트릭이 하나 있습니다. 신호가 대략 0 평균(zero mean)을 가진다면―SDR에서 보통 그렇습니다(이유는 나중에 설명)―샘플의 **분산(variance)**을 계산하면 신호 전력을 얻을 수 있습니다. 이 경우 Python에서는 이렇게 계산할 수 있습니다:

.. code-block:: python

   avg_pwr = np.var(x) # (신호가 대략 0 평균일 때)

샘플 분산이 평균 전력을 계산하는 이유는 간단합니다. 분산의 정의는 :math:`\frac{1}{N}\sum^N_{n=1} |x[n]-\mu|^2`이며, 여기서 :math:`\mu`는 신호의 평균입니다. 이 식은 앞서 본 전력 식과 매우 비슷합니다! 만약 :math:`\mu`가 0이라면, 분산 계산식은 전력 계산식과 동일해집니다. 관측 구간에서 샘플들의 평균을 빼고 분산을 계산해도 됩니다. 단, 평균이 0이 아니라면 분산과 전력은 같지 않다는 점을 알아두어야 합니다.


**********************************
Calculating Power Spectral Density
**********************************

지난 장에서 배운 대로, 신호를 FFT로 주파수 영역으로 변환하면 그 결과를 **전력 스펙트럼 밀도(PSD, Power Spectral Density)**라고 합니다. PSD는 주파수 영역에서 신호를 시각화하는 데 매우 유용하며, 많은 DSP 알고리즘이 주파수 영역에서 수행됩니다. 다만 샘플 묶음의 PSD를 실제로 구해 그리는 일은 단순히 FFT 한 번으로 끝나지 않습니다. PSD를 계산하려면 다음 여섯 단계를 거칩니다:

1. 샘플의 FFT를 취합니다. 샘플 배열 x가 있으면 기본적으로 FFT 크기는 x의 길이가 됩니다. 예를 들어 처음 1024개 샘플을 사용해 1024포인트 FFT를 만듭니다. 출력은 1024개의 복소 부동소수점 값입니다.
2. FFT 출력의 크기(magnitude)를 취해 1024개의 실수(float)를 얻습니다.
3. 그 크기를 제곱하여 전력(power)을 구합니다.
4. 정규화: FFT 크기 :math:`N`과 샘플링 주파수 :math:`Fs`로 나눕니다.
5. :math:`10 \log_{10}()`을 사용해 dB 스케일로 변환합니다. PSD는 항상 로그 스케일로 봅니다.
6. 이전 장에서 다룬 FFT shift를 수행해 “0 Hz”가 가운데 오도록 하고, 음수 주파수가 왼쪽에 오도록 정렬합니다.

위의 여섯 단계를 Python으로 구현하면 다음과 같습니다:

.. code-block:: python

   Fs = 1e6 # 예: 1 MHz로 샘플링했다고 가정
   # x에는 IQ 샘플 배열이 들어 있다고 가정
   N = 1024
   x = x[0:N] # 아래 설명처럼 처음 1024개만 FFT에 사용
   PSD = np.abs(np.fft.fft(x))**2 / (N*Fs)
   PSD_log = 10.0*np.log10(PSD)
   PSD_shifted = np.fft.fftshift(PSD_log)

선택적으로, :ref:`freq-domain-chapter` 장에서 배운 것처럼 FFT 직전에 윈도를 적용할 수 있습니다:

.. code-block:: python

   # x = x[0:1024] 뒤에 다음 줄을 추가
   x = x * np.hamming(len(x)) # Hamming 윈도 적용

PSD를 그리려면 x축 값을 알아야 합니다. 지난 장에서 보았듯, 샘플링을 하면 스펙트럼은 :math:`-Fs/2`에서 :math:`Fs/2` 사이만 “보입니다”. 주파수 영역에서의 해상도는 FFT 크기(기본적으로 FFT를 수행한 샘플 개수)에 의해 결정됩니다. 이 경우 x축은 -0.5 MHz에서 0.5 MHz까지 균일 간격의 1024점이 됩니다. 만약 SDR을 2.4 GHz에 튜닝했다면, 관측 창은 2.3995 GHz에서 2.4005 GHz 사이가 됩니다. Python에서 이 관측 중심을 옮기는 코드는 다음과 같습니다:

.. code-block:: python

   center_freq = 2.4e9 # SDR을 튜닝한 중심 주파수
   f = np.arange(Fs/-2.0, Fs/2.0, Fs/N) # 시작, 끝, 간격 — 0 Hz 중심
   f += center_freq # 중심 주파수 보정
   plt.plot(f, PSD_shifted)
   plt.show()

이제 멋진 PSD가 나올 것입니다!

수백만 개 샘플의 PSD를 구하려고 백만 포인트 FFT 같은 것을 그대로 돌리면 시간이 매우 오래 걸리고, 출력 “주파수 빈(bin)”도 너무 많아 플롯에 적합하지 않습니다. 대신 더 작은 FFT 여러 번을 구해 평균을 내거나, 스펙트로그램으로 표시하는 방법을 권합니다. 또는 신호가 빨리 변하지 않는다는 것을 안다면 수천 개 샘플만으로도 충분한 PSD를 얻을 수 있습니다. 그 시간 창 안에 신호의 특징이 충분히 담겨 보기 좋은 표현이 나옵니다.

아래는 신호(50 Hz 복소 지수)와 잡음을 생성해 PSD를 계산·플롯하는 전체 예제입니다. 여기서 N(시뮬레이션할 샘플 수)은 전체 신호에 대해 FFT를 취하므로 곧 FFT 길이가 됩니다.

.. code-block:: python

   import numpy as np
   import matplotlib.pyplot as plt

   Fs = 300  # sample rate
   Ts = 1/Fs # sample period
   N = 2048  # number of samples to simulate

   t = Ts*np.arange(N)
   x = np.exp(1j*2*np.pi*50*t)  # 50 Hz 복소 정현파

   n = (np.random.randn(N) + 1j*np.random.randn(N))/np.sqrt(2)  # 단위 전력 복소 잡음
   noise_power = 2
   r = x + n * np.sqrt(noise_power)

   PSD = np.abs(np.fft.fft(r))**2 / (N*Fs)
   PSD_log = 10.0*np.log10(PSD)
   PSD_shifted = np.fft.fftshift(PSD_log)

   f = np.arange(Fs/-2.0, Fs/2.0, Fs/N)  # 시작, 끝, 간격

   plt.plot(f, PSD_shifted)
   plt.xlabel("Frequency [Hz]")
   plt.ylabel("Magnitude [dB]")
   plt.grid(True)
   plt.show()

출력:

.. image:: ../_images/fft_example1.svg
   :align: center


******************
Further Reading
******************

#. https://web.archive.org/web/20220613052830/http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/eecs242_lect3_rxarch.pdf
